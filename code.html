<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h1>
Tree -> create , insert , mirror,min,..............
</h1>
<p>#include <iostream>
<br /><br>    using namespace std;
<br />    struct node
<br />    {
<br />        int data;
<br />        node *left,*right;
<br />    };
<br />    
<br />    class tree
<br />    {
<br />        public:
<br />            node *root,*temp;
<br />            int height1(node *T);
<br />            int print0(node *T);
<br />            node * mirror1(node *T);
<br />            tree() 
<br />            {
<br />             root=NULL;
<br />            }
<br />            void create();
<br />            void insert(node *,node *);
<br />            int height()
<br />            {
<br />            return(height1(root));
<br />            }
<br />            
<br />            void level_wise();
<br />            void preorder(node *);
<br />            void min(node *);
<br />    
<br />            void search(node *,int);
<br />    };
<br />    
<br />    class Q
<br />    {
<br />            node *data[30];
<br />            int R,F;
<br />            public:
<br />                Q(){ R=F=-1; }
<br />                void init()
<br />                {
<br />                    R=F=-1;
<br />                }
<br />    int empty()
<br />    {
<br />            if(R==-1)
<br />                return 1;
<br />            return 0;
<br />    }
<br />    
<br />    void insert(node *p)
<br />    {
<br />            if(empty())
<br />                    R=F=0;
<br />            else
<br />                    R=R+1;
<br />            data[R]=p;
<br />    }
<br />    
<br />    node *Delete()
<br />    {
<br />            node *p=data[F];
<br />            if(R==F)
<br />                R=F=-1;
<br />            else
<br />                F=F+1;
<br />            return(p);
<br />    }
<br />    };
<br />    
<br />    int tree::height1(node *T)
<br />    {
<br />            if(T==NULL)
<br />            return(0);
<br />            
<br />            if(T->left==NULL && T->right==NULL)
<br />            return(0);
<br />            
<br />        return(max(height1(T->left),height1(T->right))+1);
<br />    }
<br />  
<br />    
<br />    int tree::print0(node *T)
<br />    {
<br />            if(T==NULL)
<br />                return(0);
<br />            if(T->left==NULL && T->right==NULL)
<br />            {
<br />                cout<<" "<<T->data;
<br />                return(1);
<br />            }
<br />            return(print0(T->left)+print0(T->right));
<br />    }
<br />    
<br />    void tree::create()
<br />    {
<br />    root=NULL;
<br />        char ch;
<br />        do{
<br />        temp=new node;
<br />        cout<<" enter data"<<endl;
><br />        cin>>temp->data;
<br />        temp->left=NULL;
<br />        temp->right=NULL;
<br />        if(root==NULL)
<br />        root=temp;
<br />        else
<br />        {
<br />            insert(root,temp);
<br />        }
<br />        cout<<"do u want to continue"<<endl;
<br />        cin>>ch;
<br />        }
<br />        while(ch=='y');
<br />    }
<br />    
<br />    void tree::insert(node *root,node *temp)
<br />    {char ch1;
<br />    
<br />        if(temp->data<root->data)
<br />        {if(root->left==NULL)
<br />        root->left=temp;
<br />        else
<br />        insert(root->left,temp);
<br />        }
<br />        else if(temp->data>root->data)
<br />        {if(root->right==NULL)
<br />            root->right=temp;
<br />            else
<br />            insert(root->right,temp);
<br />        }
<br />    }
<br />    node * tree::mirror1(node *T)
<br />    {
<br />        node *temp;
<br />        if(T==NULL)
<br />            return NULL;
<br />        else
<br />        {
<br />            temp=T->left;
<br />            T->left=mirror1(T->right);
<br />            T->right=mirror1(temp);
<br />            return T;
<br />        }
<br />    }
<br />    
<br />    void tree::level_wise()
<br />    {
<br />        Q q1,q2;
<br />        node *p1,*p2;
<br />        node *T=root;
<br />        if(T==NULL)
<br />            return;
<br />        q1.insert(T);
<br />        cout<<"\n "<<T->data;
<br />        while(!q1.empty())
<br />        {
<br />            cout<<"\n";
<br />            q2.init();
<br />            while(!q1.empty())
<br />            {
<br />                p1=q1.Delete();
<br />                if(p1->left !=NULL)
<br />                {
<br />                q2.insert(p1->left);
<br />                cout<<" "<<p1->left->data;
<br />                }
<br />    
<br />                if(p1->right !=NULL)
<br />                {
<br />                q2.insert(p1->right);
<br />                cout<<" "<<p1->right->data;
<br />                }
<br />            }   
<br />    
<br />                q1=q2;
<br />       }
<br />    }
<br />    
<br />    void tree::preorder(node *root)
<br />    {
<br />        if(root!=NULL)
<br />       {
<br />        cout<<root->data;
<br />        preorder(root->left);
<br />        preorder(root->right);
<br />       }
<br />    }
<br />    
<br />    void tree::min(node *root)
<br />    {
<br />        while(root->left!=NULL)
<br />        root=root->left;
<br />        cout<<root->data;
<br />    }
<br />    
<br />    void tree::search(node * root,int x)
<br />    {
<br />        int flag=0;
<br />        while(root!=NULL)
<br />        {
<br />            if(x<root->data)
<br />            {
<br />                root=root->left;
<br />            }
<br />            else if(x>root->data)
<br />            {
<br />                root=root->right;
<br />            }
<br />            else if(x==root->data)
<br />            {
<br />                flag=1;
<br />                break;
<br />            }
<br />        }
<br />    if(flag==1)
<br />        cout<<"data found";
<br />    else 
<br />        cout<<"not found";
<br />    }
<br />    
<br />    int main()
<br />    {
<br />        tree t1;
<br />        int xx,op,x,c;
<br />        do
<br />    {
<br />        cout<<"\n\n1)Create\n2)Mirror";
<br />        cout<<"\n3)No of nodes in longest Path\n4)preorder display\n 5.minimum value\n6.Search";
<br />        cout <<"\nEnter Your Choice :"<<endl;
<br />        cin>>op;
<br />        switch(op)
<br />        {
<br />        case 1: 
<br />                t1.create();
<br />                break;
<br />        case 2:
<br />                cout<<"\n level Wise traversal on original tree \n";
<br />                t1.level_wise();
<br />                t1.root=t1.mirror1(t1.root);
<br />                cout<<"\n level Wise traversal on mirror tree \n";
<br />                t1.level_wise();
<br />                break;
<br />        case 3: 
<br />                cout<<"\nHeight = "<<t1.height();
<br />                break;
<br />        case 4:
<br />                t1.preorder(t1.root);
<br />                break;
<br />        case 5: 
<br />                t1.min(t1.root);
<br />                break;
<br />        case 6:
<br />                cout<<"enter element to search";
<br />                cin>>x;
<br />                t1.search(t1.root,x);
<br />                break;
<br />        case 7:
<br />                exit(0);
<br />        }
<br />    }
<br />    while(op!=7);
<br />    return 0;
<br />    }
<br />    
<br /></p>
<br /> <br />.<br />.<br />.<br />.<br />.<br />.<br /><br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />
<br /><p>
<br /><h1>TREE book name , chapter name ,.............</h1>
<br />#include<iostream>
<br />    using namespace std;
<br />    
<br />    struct book_node
<br />    {
<br />        char title[15];
<br />        int chapt_count;
<br />        struct book_node *down[10];
<br />        
<br />    }*root;  
<br />    
<br />    class book
<br />    {
<br />        public:
<br />            void create_tree();
<br />            void display(book_node *r);
<br />            
<br />        book()
<br />        {
<br />                root=NULL;
<br />        }
<br />    };
<br />    
<br />    void book::create_tree()
<br />    {
<br />         int i,j,k;
<br />        root=new book_node;
<br />        cout<<"Enter name of the book: "<<endl;
<br />        cin>>root->title;
<br />        cout<<"Enter total number of chapters in the book: "<<endl;
<br />        cin>>root->chapt_count;
<br />    //	cout<<root->chapt_count;
<br />        for(i=0;i<root->chapt_count;i++)
<br />        {	
<br />        root->down[i]=new book_node;
<br />        cout<<"Enter Name for chapter "<<i+1<<endl; 
<br />        cin>>root->down[i]->title;
<br />        cout<<"Enter no. of sections in  "<<root->down[i]->title<<endl;
<br />        cin>>root->down[i]->chapt_count;
<br />        cout<<"Enter details for chapter " <<i+1<<endl;
<br />        for(j=0;j<root->down[i]->chapt_count;j++)
<br />        {
<br />             
<br />        root->down[i]->down[j]=new book_node;
<br />        cout<<"Enter title for section "<<j+1<<endl;
<br />        c  in>>root->down[i]->down[j]->title;
<br />        cout<<"Enter no. of sub sections in section "<<j+1<<endl;
<br />        cin>>root->down[i]->down[j]->chapt_count;
<br />        for(k=0;k<root->down[i]->down[j]->chapt_count;k++)
<br />        {
<br />        root->down[i]->down[j]->down[k]=new book_node;
<br />        cout<<"Enter title for subsection "<<k+1<<endl;
<br />        cin>>root->down[i]->down[j]->down[k]->title;
<br />        }
<br />        }
<br />        
<br />    } 
<br />         
<br />        
<br />        
<br />    } 
<br />    
<br />    void book::display(book_node *r)
<br />    {    int i,j,k;
<br />        if(r!=NULL)
<br />        {
<br />            cout<<"****index****"<<endl; 
<br />            cout<<"Book Title: "<<r->title<<endl<<endl;
<br />            for(i=0;i<r->chapt_count;i++)
<br />            {	
<br />               cout<<"Chapter " <<i+1<<": "<<r->down[i]->title<<endl;
<br />               for(j=0;j<r->down[i]->chapt_count;j++)
<br />                {
<br />               
<br />               cout<<"Section "<<j+1<<endl;
<br />               for(k=0;k<r->down[i]->down[j]->chapt_count;k++)
<br />               {
<br />                 cout<<"Sub Section "<<k +1<<endl;
<br />               cout<<r->down[i]->down[j]->down[k]->title<<endl; 
<br />                } 
<br />              }
<br />            }
<br />            
<br />            
<br />        }
<br />    }
<br />    
<br />    int main()
<br />    {
<br />        int choice;
<br />        book book;
<br />        while(1)
<br />        {
<br />            cout<<"Menu:"<<endl;
><br />            cout<< "Book tree structure"<<endl;
><br />            cout<<"Create tree"<<endl;
><br />            cout<< "Display tree"<<endl;
><br />            cout<<"Exit"<<endl;
><br />            cout<< "Enter your choice"<<endl;
><br />            cin>>choice;
<br />            switch(choice)
<br />            {
<br />            case 1:
<br />                book.create_tree();
<br />                break;
<br />                
<br />            case 2:
<br />                book.display(root);
<br />                break;
<br />            case 3:
<br />                exit(0);
<br />                
<br />            }
<br />        }
<br />        return 0;
<br />    }
<br />    
<br /></p>
<br /> <br />.<br />.<br />.<br />.<br />.<br />.<br /><br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />
<br /><p>
<br /><h1>GRAPH -> DFS  & BFS</h1>
<br />#include<iostream>
<br />    #include<string.h>
<br />    #include<stdlib.h>
<br />    
<br />    
<br />    using namespace std;
<br />    struct vertex 
<br />    {
<br />        char name[15];
<br />        int visit;
<br />        struct vertex *next;
<br />    };
<br />    
<br />    struct vertex * lmark[20];
<br />    
<br />    struct vertex *newnode(char nm[15])
<br />    {   struct vertex *p;
<br />    
<br />        p=(struct vertex*)malloc(sizeof(struct vertex));
<br />        strcpy(p->name,nm);
<br />        p->visit=0;
<br />        p->next=NULL;
<br />    
<br />        return(p);
<br />        
<br />    }
<br />    
<br />    int search(char x[15],int n)
<br />    {
<br />        int i;
<br />        for(i=0;i<n;i++)
<br />        {
<br />            if(strcmp(lmark[i]->name,x)==0)
<br />            return i;
<br />        }
<br />    }
<br />    
<br />    
<br />    void DFS(char s[15],int n)
<br />    {
<br />    struct vertex *temp;
<br />    char stack[10][15],x[15];
<br />    int top=-1,i;
<br />    cout<<endl<<"DFS of given graph is"<<endl;
<br />    top++;
<br />    
<br />    strcpy(stack[top],s); //pushing 
<br />        while(top!=-1)
<br />        {
<br />            strcpy(x,stack[top]);//poping
<br />            top--;
<br />            i=search(x,n);
<br />            if(lmark[i]->visit==0)
<br />            {
<br />                cout <<lmark[i]->name<<endl;
<br />                lmark[i]->visit=1;
<br />            }
<br />            else
<br />            continue;
<br />            temp=lmark[i];
<br />            while(temp!=NULL)
<br />            {
<br />                top++;
<br />                strcpy(stack[top],temp->name);
<br />                temp=temp->next;
<br />            }	
<br />            
<br />        }
<br />        
<br />            
<br />    }
<br />     
<br />    
<br />    void BFS(char s[15],int n)
<br />    {
<br />    struct vertex *temp;
<br />    char Queue[10][15],x[15];
<br />    int front=-1,rear=-1,i;
<br />    cout<<endl<<"BFS of given graph is"<<endl;
<br />    if(rear==-1)
<br />    front++;
<br />    rear++;
<br />    
<br />    
<br />    strcpy(Queue[rear],s);//insert in queue
<br />    
<br />        while(rear!=-1)
<br />        {
<br />            strcpy(x,Queue[front]);//delete from queue
<br />            front++;
<br />            if(front>rear)
<br />            front=rear=-1;
<br />            i=search(x,n);
<br />            if(lmark[i]->visit==0)
<br />            {
<br />                cout <<lmark[i]->name<<endl;
<br />                lmark[i]->visit=1;
<br />            }
<br />            else
<br />            continue;
<br />            temp=lmark[i];
<br />            while(temp!=NULL)
<br />            {   
<br />                if(rear==0)
<br />                front=0;
<br />                rear++;
<br />                strcpy(Queue[rear],temp->name);
<br />                temp=temp->next;
<br />            }	
<br />            
<br />        }
<br />        
<br />            
<br />    }
<br />    
<br />    int main()
<br />    {
<br />    int n,e,i,i1,i2,choice;
<br />    char v1[15],v2[15],s[15],x[15],nm[15];
<br />    struct vertex *p,*q,*temp,*m;
<br />    cout<<"Enter number of vertices"<<endl;
<br />    cin>>n;
<br />    for(i=0;i<n;i++)
<br />    {
<br />    
<br />        cout<<"Enter name of vertex" <<i+1<<endl;
<br />        cin>>nm;
<br />        p=newnode(nm);
<br />    
<br />        lmark[i]=p;
<br />        
<br />    } 
<br />    cout<<"Enter number of edges"<<endl;
<br />    cin>>e; 
<br />    for(i=0;i<e;i++)
<br />    {
<br />        cout<<"Enter edge"<<i+1<<endl;
<br />        cin>>v1>>v2;
<br />        i1=search(v1,n);
<br />        
<br />        i2=search(v2,n);
<br />        
<br />        p=newnode(v2);
<br />        q=newnode(v1);
<br />        temp=lmark[i1];
<br />        while(temp->next!=NULL)
<br />        {
<br />            temp=temp->next;
<br />        }
<br />        temp->next=p;
<br />        
<br />        temp=lmark[i2];
<br />        while(temp->next!=NULL)
<br />        {
<br />            temp=temp->next;
<br />        }
<br />        temp->next=q;
<br />    }
<br />    
<br />    cout<<endl;
<br />    cout<<"Adjacency list is"<<endl;
<br />     for(i=0;i<n;i++)
<br />     {
<br />     
<br />        temp=lmark[i];
<br />        while(temp!=NULL)
<br />        {   cout<<temp->name<<"->";
<br />            temp=temp->next;
<br />        }
<br />        cout<<endl;
<br />    }
<br />    
<br />    
<br />    cout<<endl<<"Enter starting node"<<endl;
<br />    cin>>s;
<br />    cout<<endl;
<br />    while(1)
<br />        {
<br />    
<br />        cout<<"\nMenu:\n 1.DFS\n2.BFS\n3.Exit\n";
<br />        cout<<"Enter your choice\n";
<br />        cin>>choice;
<br />        switch(choice)
<br />        {
<br />            case 1:
<br />            for(i=0;i<n;i++)
<br />            {
<br />             lmark[i]->visit=0;
<br />            }
<br />               DFS(s,n);
<br />            break;
<br />            
<br />            case 2:
<br />            for(i=0;i<n;i++)
<br />            {
<br />             lmark[i]->visit=0;
<br />            }
<br />            BFS(s,n);
<br />            break;
<br />            case 3:
<br />            exit(0);
<br />        }//switch
<br />    
<br />        }//while
<br />    }
<br />    
<br />    
<br />    
<br />    
<br />    
<br /></p>
<br />.<br />.<br />.<br />.<br />.<br />.<br /><br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />
<br /><p>
<br />   <h1> /* Group B- Assignment No. 11
<br />    You have a business with several offices; you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to connect different pairs of cities. You want a set of lines that connects all your offices with a minimum
<br />    total cost. Solve the problem by suggesting appropriate data structures.
<br />    */</h1>
<br />    #include<stdlib.h>
<br />    #include<iostream>
<br />    #define inf 9999
<br />    using namespace std;
<br />    
<br />    class prims
<br />    {
<br />    public:
<br />        int cost[10][10],vertex,edge;
<br />        void creategraph();
<br />        void primfun(int);
<br />    };
<br />    
<br />    
<br />    void prims::creategraph()
<br />    {
<br />          int v1,v2,i,j,wt;
<br />           cout<<"\n\t\t Enter the MAXIMUM no of offices:::";
<br />           cin>>vertex;
<br />           cout<<"\n\t\t Enter the no of lease lines:::";
<br />           cin>>edge;
<br />       //	initialize cost matrix
<br />          for(i=0;i<vertex;i++)
<br />              for(j=0;j<vertex;j++)
<br />                  {
<br />                      if(i==j)
<br />                     cost[i][j]=0;
<br />                     else
<br />                      cost[i][j]=inf;
<br />                }
<br />        //enter information about lease lines		
<br />           for(i=0;i<edge;i++)
<br />           {
<br />            cout<<"\n\t\t Enter the lease lines (edge) and Their costs(v1,v2,wt)::"; 
<br />            cin>>v1>>v2>>wt;
<br />            cost[v1][v2]=cost[v2][v1]=wt;
<br />           }
<br />    }
<br />    
<br />    void prims::primfun(int s)
<br />    {
<br />      int min,i,j,n=1,visited[10],dist[10],from[10],nextnode,mstcost=0;
<br />    
<br />    //initialization
<br />      for(i=0;i<vertex;i++)
<br />      {
<br />       visited[i]=0;
<br />       dist[i]=inf;
<br />       from[i]=s;
<br />      }
<br />      //start node visited
<br />     visited[s]=1;
<br />        
<br />    
<br />        //update distance array 
<br />        
<br />        for(i=0;i<vertex;i++)
<br />        {
<br />            if(visited[i]==0&&cost[s][i]<dist[i])
<br />            {
<br />                dist[i]=cost[s][i];
<br />                
<br />            }
<br />            
<br />            
<br />        }
<br />        //for vertex-1 no of edges
<br />       while(n<vertex)
<br />       {
<br />        min=inf;
<br />        
<br />        //find next node to visit	
<br />        for(i=0;i<vertex;i++)
<br />        {
<br />            if(visited[i]==0&&dist[i]<min)
<br />            {
<br />                min=dist[i];
<br />                nextnode=i;
<br />                
<br />            }
<br />        }
<br />        
<br />        cout<<endl<<from[nextnode]<<"  "<<nextnode<<endl;
<br />        n++;
<br />        visited[nextnode]=1;
<br />        mstcost+=dist[nextnode];
<br />    //update distance array
<br />    
<br />        for(i=0;i<vertex;i++)
<br />        {
<br />            if(visited[i]==0 && dist[i]>cost[nextnode][i])
<br />            {
<br />            dist[i]=cost[i][nextnode];
<br />            from[i]=nextnode;
<br />            }
<br />                
<br />        }
<br />        
<br />    }//while end
<br />    
<br />        
<br />       cout<<"\n\tCost of minimun spanning tree is::"<<mstcost<<endl;
<br />    
<br />    }
<br />    
<br />    int main()
<br />    {
<br />       prims s1;
<br />       
<br />       int ch;
<br />        while(1)
<br />        {
<br />    
<br />             cout<<"\n 1.Readgraph and Creategraph \n 2.Prims Algorithm \n 3.Exit.\n";
<br />             cout<<"\n\nEnter Ur Choice= ";
<br />             cin>>ch;
<br />             switch(ch)
<br />             {
<br />    
<br />             case 1:
<br />                 s1.creategraph();
<br />                     break;
<br />    
<br />             case 2:
<br />                    int start;
<br />                    cout<<"\nEnter Starting Vertex=";
<br />                    cin>>start;
<br />                    cout<<endl<<"MST is: "<<endl;
<br />                    s1.primfun(start);
<br />                     break;
<br />    
<br />             case 3:exit(0);
<br />             }
<br />         }
<br />       return 0;
<br />    }
<br />     
<br />    ></p>
<br />.<br />.<br />.<br />.<br />.<br />.<br /><br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />
<br />    <p>
<br />        #include<iostream>
<br />            #include<string>
<br />            
<br />            #define N 20
<br />            
<br />            #define SERIOUS 10
<br />            #define NONSERIOUS 5
<br />            #define CHECKUP 1
<br />            
<br />            using namespace std;
<br />            string Q[N];  //Size of Queue
<br />            int Pr[N];   //FOR CATAGORY OF Patient 
<br />            int r = -1,f = -1;
<br />            void enqueue(string name,int p)//Enqueue function to insert data and its priority in queue
<br />            {
<br />                int i;
<br />                if((f==0)&&(r==N-1)) //Check if Queue is full
<br />                    cout<<"Queue is full";
<br />                else {
<br />                    if(f==-1) { //if Queue is empty
<br />                        f = r = 0;
<br />                        Q[r] = name;         //FIRST ENTRY
<br />                        Pr[r] = p;           //FIRST ENTRY
<br />            
<br />                    }
<br />                
<br />                    else {      //second patient onwards
<br />                        for(i = r;i>=f;i--) {
<br />                            if(p>Pr[i]) //if priority of the new patient is > exixting patient then shift the existing patient one place right
<br />                            {
<br />                                Q[i+1] = Q[i];
<br />                                Pr[i+1] = Pr[i];	
<br />                            }
<br />                            else break;
<br />                        }
<br />                        Q[i+1] = name;
<br />                        Pr[i+1] = p;
<br />                        r++;
<br />                    }	
<br />                }
<br />            
<br />            }
<br />            void print() { //print the data of Queue
<br />                int i;
<br />                for(i=f;i<=r;i++) {
<br />                    cout << "Patient's Name - "<<Q[i];
<br />                    switch(Pr[i]) {
<br />                        case 1: 
<br />                            cout << " Priority - 'Checkup' " << endl;
<br />                        break;
<br />                        case 5:
<br />                            cout << " Priority - 'Non-serious' " << endl;
<br />                        break;
<br />                        case 10:
<br />                            cout << " Priority - 'Serious' " << endl;
<br />                        break;
<br />                        default:
<br />                            cout << "Priority not found" << endl;
<br />                    }
<br />                }
<br />            }
<br />            
<br />            void dequeue() { //remove the data from front
<br />                if(f == -1) {
<br />                    cout<<"Queue is Empty";
<br />                }	
<br />                else {
<br />                cout<<"deleted Element ="<<Q[f]<<endl;
<br />                cout<<"Its Priority = "<<Pr[f]<<endl;
<br />                    if(f==r) f = r = -1;
<br />                    else f++;
<br />                }
<br />            }
<br />            
<br />            int main() 
<br />            {
<br />                string name;
<br />                int opt,n,i,p;
<br />                cout<<"Enter Your Choice:-"<<endl;
<br />                do {
<br />                cout << "Enter 1 for Inserting the Data in Queue" << endl << "Rnter 2 for showing the Data in Queue " << endl << "Enter 3 for Deleting the data from the Queue" 
<br />                    << endl << "Enter 0 to Exit"<< endl;
<br />                cin >> opt;
<br />                    switch(opt) 
<br />                    {
<br />                        case 1:
<br />                            cout << "Enter the number of patinent" << endl;
<br />                            cin >> n;
<br />                            i = 0;
<br />                            while(i < n) 
<br />                            {
<br />                                cout << "Enter your name of the patient : ";
<br />                                cin >> name;
<br />                                ifnotdoagain: 
<br />                                    cout << "Enter your Prioritys (0: Serious, 1: Non-serious, 2: General checkup) : ";
<br />                                    cin >> p;
<br />                                    switch(p) {
<br />                                        case 0: 
<br />                                            enqueue(name,SERIOUS);
<br />                                        break;
<br />                                        case 1: 
<br />                                            enqueue(name,NONSERIOUS);
<br />                                        break;
<br />                                        case 2: 
<br />                                            enqueue(name,CHECKUP);
<br />                                        break;
<br />                                        default:
<br />                                            goto ifnotdoagain;
<br />                                    }
<br />                                    
<br />                                i++;
<br />                            }
<br />                        break;
<br />                        case 2:
<br />                            print();
<br />                        break;
<br />                        case 3:
<br />                             dequeue();
<br />                        break;
<br />                        case 0:
<br />                            cout << "Bye Bye !" << endl;
<br />                        break;
<br />                        default:
<br />                        cout<<"Incorrect Choice"<<endl;
<br />            
<br />                    }
<br />                }while(opt!=0);
<br />                    return 0;
<br />            }
<br />            
<br />            
<br />            
<br />            
<br />            
<br />    ></p>
<br />    <p>
<br /> <br />.<br />.<br />.<br />.<br />.<br />.<br /><br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />.<br />
<br /><h1>* Group E - Assignment No. 23
<br />Problem Statement- 
<br />Department maintains a student information. The file contains roll number, name, division
<br />and address. Allow user to add, delete information of student. Display information of
<br />particular student. If record of student does not exist an appropriate message is displayed.
<br />If it is, then the system displays the student details. Use sequential file to main the data.
<br />
<br />*/</h1>
<br />
<br />#include<iostream>
<br />#include<stdlib.h>
<br />#include<fstream>
<br />#include<string.h>
<br />#include<iomanip>
<br />
<br />
<br />using namespace std;
<br />
<br />class student
<br />{
<br />
<br />string name,div,address;
<br />int roll;
<br />public:
<br /> void getdata();
<br /> void displayAll();
<br /> void insert_record();
<br /> void delete_record();
<br /> void search_record();
<br />};
<br />
<br />
<br />void student::getdata()
<br />{
<br /> cout<<"\nEnter Roll No, Division, Name and Address of Student= ";
<br /> cin>>roll>>div>>name>>address;
<br /> 
<br />} 
<br />void student::insert_record()
<br />{
<br />	fstream out;
<br />	student *s1;
<br />	s1=new student;
<br />	out.open("Record11.txt",ios::app|ios::binary);
<br />	
<br />	s1->getdata();
<br />	out.write((char *)&s1,sizeof(s1));
<br />	
<br />	out.close();
<br />}
<br />
<br />void student::displayAll()
<br />{
<br />	fstream out;
<br />	student *s2;
<br />	s2=new student;
<br />	out.open("Record11.txt",ios::in|ios::binary);
<br />	
<br />	cout<<"\nThe Contents of file are.......\n\n";
<br />	cout<<"\nROLL"<<setw(15)<<"Division"<<setw(15)<<"NAME"<<setw(15)<<"ADDRESS\n";
<br />	
<br />	while(out.read((char*)&s2,sizeof(s2)))
<br />	{
<br />		cout<<"\n"<<s2->roll<<setw(15)<<s2->div<<setw(15)<<s2->name<<setw(15)<<s2->address;
<br />	}
<br />	cout<<"\n";
<br />	out.close();
<br />}
<br />void student::delete_record()
<br />{
<br />	fstream out,temp;
<br />	student *s2;
<br />	int item;
<br />	s2=new student;
<br />	out.open("Record11.txt",ios::in|ios::binary);
<br />	temp.open("temp.txt",ios::out|ios::binary);
<br />	cout<<"\nEnter Roll_No :";
<br />	cin>>item;
<br />	while(out.read((char*)&s2,sizeof(s2)))
<br />	{
<br />		    if(s2->roll!=item)
<br />			{
<br />				temp.write((char *)&s2,sizeof(s2));
<br />			}
<br />	}
<br />	out.close();
<br />	temp.close();
<br />	
<br />	remove("Record11.txt");
<br />	rename("temp.txt","Record11.txt");
<br />	
<br />	
<br />}
<br />void student::search_record()
<br />{
<br />	int item,flag=0;
<br />	student *s2;
<br />	fstream out;
<br />	out.open("Record11.txt",ios::in|ios::binary);
<br />	s2=new student;
<br />	cout<<"\nEnter Roll_No :";
<br />	cin>>item;
<br />	
<br />	while(out.read((char*)&s2,sizeof(s2)))
<br />	{
<br />			if(s2->roll==item)
<br />			{
<br />				cout<<"\n Record is Present in the File....\n ";
<br />				cout<<"\n"<<s2->roll<<"\t"<<s2->div<<"\t"<<s2->name<<"\t"<<s2->address;
<br />				flag=1;
<br />				break;
<br />			}
<br />		
<br />	}
<br />	if(flag==0)
<br />	cout<<endl<<"Sorry .No such Record Present"<<endl;
<br />	out.close();
<br />}
<br />
<br />int main()
<br />{
<br />	student t1;
<br />	int ch;
<br />    fstream out;
<br />	out.open("Record11.txt",ios::out);
<br />	out.close();
<br />	while(1)
<br />	{
<br />		cout<<"\n*******  SEQUENTIAL ACCESS FILE PROGRAM USING C++ ********** \n\n";
<br />		cout<<"\n1.INSERT RECORD\n2.DISPLAY All Records \n3.SEARCH\n4.Delete\n5.EXIT.";
<br />		cout<<"\nEnter UR Choice : ";
<br />		cin >> ch;
<br />		switch(ch)
<br />		{
<br />		case 1:
<br />			
<br /> 			t1.insert_record();
<br /> 	
<br />			cout<<"\n\nRecord is Inserted..\n\n";
<br />			break;
<br />		case 2:
<br />			t1.displayAll();
<br />			break;
<br />		case 3:
<br />			t1.search_record();
<br />			break;
<br />		case 4:
<br />			t1.delete_record();
<br />			break;
<br />		case 5:
<br />			exit(0);
<br />		}
<br />	}
<br />	return 0;
<br />}
<br />
<br />
<br />    </p>
<br />
<br />
<br />
<br />
</body>
</html>
